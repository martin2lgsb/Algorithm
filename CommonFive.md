# 五种常用算法

### 一、分治算法

#### （一）基本概念

​	在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，愿问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法（快速排序，归并排序），傅立叶变换（快速傅立叶变换）……

​	任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，阶梯所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需要任何计算。n=2时，只需要做一次比较即可排好序。n=3时只要做3次比较即可，……。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。

#### （二）基本思想及策略

​	分治法的设计思想是：讲一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。

​	分治策略是：对于一个规模为n的问题，若该问题可以容易的解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归的解决这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。

如果愿问题可分割成k个子问题，1<k≤n, 且这些子问题都可解并可利用这些子问题的解求出愿问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是愿问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与愿问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一堆孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。

#### （三）分治法使用场景

分治法所能解决的问题一般具有以下几个特征：

+ 该问题的规模缩小到一定的程度就可以容易的解决
+ 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质
+ 利用该问题分解出的子问题的解可以合并为该问题的解
+ 利用该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题

**第一条特征**是绝大多数问题都可以满足的，因为问题的计算法扎醒一版是随着问题的规模的增加而增加的。

**第二条特征**是应用分治法的前提，它也是大多数问题可以满足的，此特征反映了递归思想的应用。

**第三条特征**是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一、第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。

**第四条特征**涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复的解决公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。

#### （四）分治法得基本步骤

分治法在每一层递归上都有三个步骤：

+ Step1 分解：将原问题分解为若干个规模较小，相互独立，与愿问题形式相同的子问题
+ Step2 解决：若子问题规模较小而容易被解决则直接解，否则递归的解各个子问题
+ Step3 合并：将各个子问题的解合并为愿问题的解

他的一般算法设计模式如下：

Divide-and-Conquer(P)

1. if |P|≤n0
2. then return(ADHOC(P))
3. 将P分解为较小的子问题 P1,P2,...,Pk
4. for i <- 1 to k
5. do yi <- Divide-and-Conquer(Pi)△ 递归解决Pi
6. T <- MERGE(y1,y2,...,yk)△ 合并子问题
7. return(T)

其中|P|表示问题P的规模；n0为阀值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必在继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,...,yk)是该分治法中的合并子算法，用于将P的子问题P1,p2,…,Pk的响应的解y1,y2,...,yk合并为P的解。

#### （五）分治法的复杂性分析

​	一个分治法将规模为n的问题分解成k个规模为n/m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题消耗1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：

T(n) = kT(n/m) + f(n)

通过迭代法求得方程的解：

递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的增长速度。通常假定T(n)的增长速度。通常假定T(n)是单调上升的，从而当mi≤n≤mi+1时，T(mi)≤T(n)<T(mi+1)。

#### （六）可使用分治法求解的一些经典问题

+ 二分搜索
+ 大整数乘法
+ Strassen矩阵乘法
+ 期盼覆盖
+ 合并排序
+ 快速排序
+ 线性时间选择
+ 最接近点对问题
+ 循环赛日程表
+ 汉诺塔

#### （七）一些经典问题求解代码实现

1. 二分搜索

   二分搜索又叫二分查找、折半查找，它是一种效率较高的查找方法。

   二分搜索的要求：

   线性表为有序表，并且要用向量作为表的储存结构。

   二分搜索的基本思想：先确定待查找记录所在的范围，然后逐步缩小范围直至找到或找不到该记录位置。

   二分查找位置：

   + 先确定中间位置：middle = (left+right)/2
   + 将待查找的key值与data[middle].key值相比较。若相等，则查找成功并返回该位置，否则须确定新的查找区间，继续二分查找。

2. 汉诺塔

   ​	在汉诺塔游戏中，有三个分别命名为A、B、C的塔座，几个大小各不相同，从小到大一次编号得圆盘，每个圆盘中间有一个小孔。最初，所有的圆盘都在A塔座上，其中最大的圆盘在最下面，然后是二大，以此类推。

   ​	游戏的目的是将所有的圆盘从塔座A移动到塔座B；塔座C用来防治临时圆盘，游戏规则如下：

   1. 一次只能移动一个圆盘
   2. 任何时候都不能讲一个较大的圆盘压在较小的圆盘上面
   3. 除了第二条限制，任何塔座的最上面的圆盘都可以移动到其他塔座上

   汉诺塔问题解决思想：

   ​	在解决汉诺塔问题时，事实上，我们不是关心最上面的圆盘开始应该挪到那个塔座上，而是关心最下面的圆盘。当然我们不能直接移动最下面的圆盘，但是最终是要把最下面的圆盘从塔座A移动到塔座B。

   ​	我们仍将分析，如何将前三个圆盘从A移动到C，然后把最下面的圆盘从A移动到C再移动到B。

   ​	但是上面的步骤可以重复利用！持续简化这个问题，最终我们将处理一个圆盘从一个塔座移动到另外一个塔座的问题。

### 二、动态规划算法

#### （一）基本思想

​	动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到愿问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到的子问题往往不是相互独立的。若用分治法来解决这类问题，则分解得到的子问题数目太多，有些子问题呗重复计算了很多次。如果我们能够保存已经解决子问题的答案，而在需要时再找出已求得的答案，这样就避免了大量重复的计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要他被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。

​	动态规划算法与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到后的子问题往往不是互相独立的（即下一个阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）

#### （二）应用场景

适用动态规划的问题必须满足最优化原理，无后效性和重叠性。

1. **最优化原理** （最优子结构性质）最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质。
2. **无后效性** 将个阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前个阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。
3. **子问题的重叠性** 动态规划将原来具有指数时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于解决冗余。

#### （四）动态规划算法经典案例

案例一：

有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法。

分析：动态规划的实现的关键在于能不能准确合理的用动态规划表来抽象出实际问题。在这个问题上，我们让f(n)表示走上n级台阶的方法数。

那么当n为1时，f(n)=1，n为2时，f(n)=2，就是说当台阶只有一级的时候，方法数是一种，台阶有两级的时候，方法数为2.那么当我们要走上n级台阶，必然是n-1级台阶迈一步或者是从n-2级台阶迈两步，所以到达n级台阶的方法数必然是到达n-1级台阶的方法数加上到达n-2级台阶的方法数之和。即f(n)=f(n-1)+f(n-2)，我们用dp[n]来表示动态规划表，dp[i],i>0,i<=n，表示到达i级台阶的方法数。

案例二:

给定一个矩阵m，从左上角开始每次只能向右走或者向下走，最后到达右下角的位置，路径中所有数字累加起来就是路径和，返回所有路径的最小路径和，如果给定的m如下，那么路径1,3,1,0,6,1,0就是最小路径和，返回12。

$$\begin{bmatrix}1&3&5&9\\8&1&3&4\\5&0&6&1\\8&8&4&0\end{bmatrix}$$ 

分析：对于这个题目，假设m是m行n列的矩阵，那么我们用$dp[m][n]$ 来抽象这个问题，$dp[i][j]$ 表示的是从原点到i, j位置的最短路径和。我们首先计算第一行和第一列，直接累加即可，对于其他位置，要么从左遍位置到达，要么是从上边位置到达，我们取左边和上边的较小值，然后加上当前的路径值，就是达到当前点的最短路径。然后从左到右，从上到下一次计算即可。

案例三：

最长公共子序列的问题是要找两个字符串间的最长公共子序列。假设有两个字符串sudjxidjs和xidjxidpolkj，其中djxidj就是它们的最长公共子序列。许多问题都可以看成是公共子血猎的变形。例如语音识别问题就可以看成最长公共子序列问题。

假设两个字符串分别为A=a1a2..am, B=b1b2..bn，则m为A的长度，n为B的长度。那么它们的最长公共子序列分为两种情况。

1. $a_{m}=b_{n}$ ，这时他们的公共子序列一定为的长度$F(m, n)=F(m-1, n-1)+a_{m}$ ;
2. $a_{m} \neq b_{n}$ ，这时他们的公共子序列一定为的长度$F(m, n)=Max(F(m-1, n), F(m, n-1))$ ;

### 三、贪心算法

#### （一）基本思想

贪心算法是指：在每一步求解的步骤中，他要求“贪婪”的选择最佳操作，并希望通过一些列的最优选择，能够产生一个问题的（全局的）最优解。

贪心算法每一步必须满足以下条件：

1. 可行的：即它必须满足问题的约束。
2. 局部最优：他是当前步骤中所有可行选择中最佳的局部选择。
3. 不可取消：即选择一旦做出，在算法的后面步骤就不可改变了。

#### （二）应用案例

案例一：

活动选择问题，这是《算法导论》上的例子，也是一个非常经典的问题。有n个需要在同一天使用同一个教师的活动a1,a2,...,an，教师同一时刻只能由一个活动使用。每个活动ai都有一个开始时间si和结束时间fi。一旦选择后，活动ai就占据半开时间区间[ai, fi)。如果[si, fi]和[sj, fj]互不重叠，ai和aj两个活动就可以被安排在这一天。该问题就是要安排这些活动，是的尽量多的活动能不冲突的巨星。例如下图所示的活动集合S，其中各项活动按照结束时间单调递增排序。

用贪心法的话思想很简单：活动越早结束，剩余时间是不是越多？那我就找最早结束的那个活动找到后在剩下的活动中再找最早结束的不就得了？

虽然贪心算法的思想简单，但是贪心法不能保证能得到问题的最优解，如果得不到最优解，那就不是我们想要的东西了，所以我们现在要证明的是在这个问题中，用贪心法能得到最优解。

案例二：

钱币找零问题，这个问题在我们的日常生活中就更加普遍了。假设1,2,5,10,20,50,100的纸币分别有c0,c1,c2,c3,c4,c5,c6张。现在要用这些钱来支付K元，至少要用多少张纸币？用贪心算法的思想，很明显，每一步尽可能用面纸大的纸币即可。在日常生活中我们自然而然也是这么做的。在程序中已经实现将Value按照从小到大的顺序排好。

有些情况，贪心算法缺失可以给出最优解，然而，还有一些问题并不是这种情况。对于这种情况，我们关心的是近似解，或者只能满足于近似解，贪心算法也是有价值的。